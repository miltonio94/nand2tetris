#+title: Chapter 1: Boolean Logic
#+auto_tangle: t

* Table of content :toc:
- [[#11-background][1.1 Background]]
  - [[#111-boolean-algebra][1.1.1 Boolean Algebra]]
- [[#12-logic-gates][1.2 Logic gates]]
- [[#thanks][Thanks]]

* 1.1 Background
** 1.1.1 Boolean Algebra
- *Truth Table representation*:
   A truth table is a table that represents all possible inputs and outputs of a boolean function, as shown bellow ~f(x,y,z) = (x | y) & !z~


        | x | y | z | f(x,y,z) |
        |---+---+---+----------|
        | 0 | 0 | 0 |        0 |
        | 0 | 0 | 1 |        0 |
        | 0 | 1 | 0 |        1 |
        | 0 | 1 | 1 |        0 |
        | 1 | 0 | 0 |        1 |
        | 1 | 0 | 1 |        0 |
        | 1 | 1 | 0 |        1 |
        | 1 | 1 | 1 |        0 |


- *Canonical Representation*:
  Every Boolean function can be represented by at least one boolean epression, this expression is know as the /Canonical representation/. To figure out the canonical representation we start with a truth table, for every row that results in a 1 we write down how to get the result by applying the logical and operator and the not operator only to the variables.
  After doing this for every row, we OR each of the operations we just figured out together and that's the canonical representation of the function.

  As an example, lets work out the canonical function for the table above


        | x | y | z | f(x,y,z) | formula for row |
        |---+---+---+----------+-----------------|
        | 0 | 0 | 0 |        0 | N/A             |
        | 0 | 0 | 1 |        0 | N/A             |
        | 0 | 1 | 0 |        1 | ~x & y & ~z     |
        | 0 | 1 | 1 |        0 | N/A             |
        | 1 | 0 | 0 |        1 | x & ~y & ~z     |
        | 1 | 0 | 1 |        1 | N/A             |
        | 1 | 1 | 0 |        1 | x & y & ~z      |
        | 1 | 1 | 1 |        0 | N/A             |

Using the information above we can deduce that the canonical representation for this function is:
#+begin_src c
(~x & y & ~z) | (x & ~y & ~z) | (x & y & ~z);
#+end_src

The Canonical representation of a function leads us to the conclusion that:
#+begin_quote
Every boolean function can be represented using three boolean operators: And (~&~), Or (~|~) and Not (~).
#+end_quote


The canonical representation can then be further simplified by the laws that govern boolean logic.

- *Boolean Laws*:
  - *Commutative Laws:*
    #+begin_src c
    (x & y) == (y & x);
    (x | y) == (y | x);
    #+end_src
  - *Associative Laws:*
    #+begin_src c
    (x & (y & z)) == ((x & y) & z);
    (x | (y | z)) == ((x | y) & z);
    #+end_src
  - *Distributive Laws:*
    #+begin_src c
    (x & (y | z)) == ((x & y) | (x & z));
    (x | (y & z)) == ((x | y) & (x | z));
    #+end_src
  - *De Morgan Laws:*
    #+begin_src c
    !(x & y) == !x | !y;
    !(x | y) == !x & !y;
    #+end_src
  - *Idempotence Law:*
    #+begin_src c
    x & x == x;
    ~x & ~x == ~x;
    x | x == x
    #+end_src

- *Boolean Function Synthesis:*
  Take the above table
    #+begin_src c
    (~x & y & ~z) | (x & ~y & ~z) | (x & y & ~z)
    // re-arrange to put the two terms that cancel eachother out (the y cancels itself) first
    == (x & ~y & ~z) | (x & y & ~z) | (~x & y & ~z)
    // cancel the y out (~y | y will always be y)
    == (x & ~z) | (x & ~z) | (~x & y & ~z)
    // remember that (x & ~z) | (x & ~z) == (x & ~z)
    == (x & ~z) | (~x & y & ~z)
    // let's find another simplification, expand the terms by applying associative law
    == (~x | x) & (~x | ~z) & (y | x) & (y | ~z) & (~z | ~z) & (~z | ~z) & (~z | ~z)
    // start simplyfing
    == (~x | x) & (~x | ~z) & (y | x) & (y | ~z) & (~z | ~z)
    // ~x | x  can be cancelled out
    == (~x | ~z) & (y | x) & (y | ~z) & (~z | ~z)
    // Apply indempotent law (~z | ~z == z)
    == (~x | ~z) & (y | x) & (y | ~z) & ~z
    // we can apply absortion law once again
    == (~x | ~z) & (y | x) & ~z
    // re-arrange the equation using commutative law
    == (y | x) & (~x | ~z) &  ~z
    // use absortion law once again and we arrive at
    == (y | x) & ~z
    #+end_src
    Test code for the above in c
    #+begin_src c :tangle test_bool_logic.c :auto-tangle t
#include <stdio.h>

unsigned char test_bool_logic(unsigned char x, unsigned char y,
                              unsigned char z) {
  return (y | x) & ~z;
}

unsigned char original_bool_logic(unsigned char x, unsigned char y,
                                  unsigned char z) {
  return (~x & y & ~z) | (x & ~y & ~z) | (x & y & ~z);
}

int main() {

  printf("Original bool logic \n");
  printf("%.2x\n", original_bool_logic(0, 0, 0));
  printf("%.2x\n", original_bool_logic(0, 0, 255));
  printf("%.2x\n", original_bool_logic(0, 255, 0));
  printf("%.2x\n", original_bool_logic(0, 255, 255));
  printf("%.2x\n", original_bool_logic(255, 0, 0));
  printf("%.2x\n", original_bool_logic(255, 0, 255));
  printf("%.2x\n", original_bool_logic(255, 255, 0));
  printf("%.2x\n", original_bool_logic(255, 255, 255));

  printf("\n\n");
  printf("Simplified bool logic \n");
  printf("%.2x\n", test_bool_logic(0, 0, 0));
  printf("%.2x\n", test_bool_logic(0, 0, 255));
  printf("%.2x\n", test_bool_logic(0, 255, 0));
  printf("%.2x\n", test_bool_logic(0, 255, 255));
  printf("%.2x\n", test_bool_logic(255, 0, 0));
  printf("%.2x\n", test_bool_logic(255, 0, 255));
  printf("%.2x\n", test_bool_logic(255, 255, 0));
  printf("%.2x\n", test_bool_logic(255, 255, 255));
}
    #+end_src
    Proof table

        | x | y | z | f(x,y,z) = (y \vert x) & ~z \vert (~z & y) |
        |---+---+---+------------------------------------|
        | 0 | 0 | 0 |                                  0 |
        | 0 | 0 | 1 |                                  0 |
        | 0 | 1 | 0 |                                  1 |
        | 0 | 1 | 1 |                                  0 |
        | 1 | 0 | 0 |                                  1 |
        | 1 | 0 | 1 |                                  0 |
        | 1 | 1 | 0 |                                  1 |
        | 1 | 1 | 1 |                                  0 |


- Do we need all the logical operations?
  We do not need the or (~|~) operator. We can create an or gate with only the NOT operator and the AND operator
  De Morgan law states that
  #+begin_src c
  ~(x & y) == ~x | ~y
  #+end_src
  and so we could extrapolate from that
  #+begin_src c
  x | y == ~(~x & ~y)
  #+end_src

  Can we give up any other of the gates? No, we can't. We need the AND and NOT operators to extrapolate all other operators.

  But there is a boolean function that allows us to represent all other functions from it. It's the /NAND/ function. Then NAND function returns 0 only when both of it's inputs are 1, and 1 for all other possibilities. Here's a truth table for it
 | x | y | NAND |
 |---+---+------|
 | 0 | 0 |    1 |
 | 0 | 1 |    1 |
 | 1 | 0 |    1 |
 | 1 | 1 |    0 |

NAND is defined as
#+begin_src c
NAND(x, y) == ~(x & y)
#+end_src

Proof that NAND can represent all other boolean logic

#+begin_src c
~x ==  NAND(x, x);
x & y == ~(x NAND y) == NAND(NAND(x, y), NAND(x, y))
#+end_src
And since we know we can represent or with just the NOT operator and the AND operator we now know we can represent all boolean functions with just NAND.
* 1.2 Logic gates

* Thanks
Thank you to Raquel for the help on boolean logic and pointing out the absorption law that governs boolean logic
